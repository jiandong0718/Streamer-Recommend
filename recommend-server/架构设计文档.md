# 推荐系统架构设计文档

## 1. 系统总体架构

### 1.1 架构概述
本推荐系统采用微服务架构设计，基于Spring Boot + Spring Cloud + Nacos技术栈，提供高性能、高可用的主播推荐服务。

### 1.2 技术栈
- **基础框架**: Spring Boot 2.7.0, Spring Cloud 2021.0.3
- **服务治理**: Nacos (服务注册与配置中心)
- **数据存储**: MySQL 8.0 (主从), Redis 6.0 (集群), Elasticsearch 7.x, HBase
- **缓存框架**: JetCache + Redis + Caffeine (多级缓存)
- **监控工具**: Prometheus + Grafana + Druid + Actuator
- **消息队列**: RocketMQ (异步处理)
- **搜索引擎**: Elasticsearch (全文检索)

### 1.3 系统特性
- **高性能**: 多级缓存 + 异步处理 + 连接池优化
- **高可用**: 服务集群 + 熔断降级 + 优雅降级
- **可扩展**: 微服务架构 + 水平扩展 + 插件化算法
- **国际化**: 多语言支持 + 地域化推荐
- **监控**: 全链路监控 + 实时告警 + 性能分析

## 2. 核心组件架构

### 2.1 Controller层 (控制器层)
```
RecommendController        # 推荐服务主控制器
├── getPersonalRecommend   # 个性化推荐
├── getHotRecommend       # 热门推荐
├── getBatchRecommend     # 批量推荐
└── recordFeedback        # 用户反馈记录

StreamerSearchController   # 主播搜索控制器
├── searchBySkill         # 技能匹配搜索
├── searchNewbie          # 新手推荐
├── searchNearby          # 附近主播
└── getRecommendTags      # 推荐标签

HealthController          # 健康检查控制器
├── health               # 基础健康检查
├── detailedStatus       # 详细系统状态
└── jvmInfo             # JVM监控信息
```

### 2.2 Service层 (业务逻辑层)
```
RecommendService          # 推荐业务核心服务
├── getPersonalRecommend  # 个性化推荐算法
├── getHotRecommend      # 热门推荐算法
├── recordUserBehavior   # 用户行为记录
└── updateUserProfile    # 用户画像更新

StreamerSearchService     # 主播搜索业务服务
├── searchByMultiCriteria # 多条件搜索
├── getSkillMatching     # 技能匹配算法
├── getNearbyStreamers   # 地理位置搜索
└── getPersonalizedTags  # 个性化标签推荐

UserProfileService        # 用户画像服务
├── buildUserProfile     # 构建用户画像
├── updateProfile        # 更新用户画像
├── calculatePreference  # 计算用户偏好
└── getProfileCache      # 获取缓存画像

RecommendCacheService     # 推荐缓存服务
├── cacheRecommendResult # 缓存推荐结果
├── getUserProfile       # 获取用户画像缓存
├── getHotStreamers      # 获取热门主播缓存
└── invalidateCache      # 缓存失效处理
```

### 2.3 Algorithm层 (算法层)
```
CollaborativeFilteringAlgorithm  # 协同过滤算法
├── userBasedCF                  # 基于用户的协同过滤
├── itemBasedCF                  # 基于物品的协同过滤
├── matrixFactorization          # 矩阵分解算法
└── calculateSimilarity          # 相似度计算

ContentBasedAlgorithm            # 基于内容的推荐算法
├── calculateContentSimilarity   # 内容相似度计算
├── extractFeatures             # 特征提取
├── buildItemProfile            # 物品画像构建
└── matchUserPreference         # 用户偏好匹配

HybridAlgorithm                 # 混合推荐算法
├── weightedHybrid              # 加权混合
├── switchingHybrid             # 切换混合
├── cascadingHybrid             # 级联混合
└── featureCombination          # 特征组合

FeatureExtractor                # 特征提取器
├── calculateRelevanceScore     # 相关性评分
├── calculateQualityScore       # 质量评分
├── calculatePopularityScore    # 流行度评分
└── calculatePriceScore         # 价格评分
```

### 2.4 Data Access层 (数据访问层)
```
UserMapper                 # 用户数据访问
├── selectUserById         # 根据ID查询用户
├── selectUserBehaviors    # 查询用户行为
├── selectUserTags        # 查询用户标签
└── updateUserProfile     # 更新用户画像

StreamerMapper            # 主播数据访问
├── selectActiveStreamers # 查询活跃主播
├── selectByTags          # 根据标签查询
├── selectBySkills        # 根据技能查询
└── selectByRegion        # 根据地区查询

OrderMapper               # 订单数据访问
├── selectUserOrders      # 查询用户订单
├── selectOrdersByStreamer # 查询主播订单
├── calculateOrderStats   # 计算订单统计
└── selectRecentOrders    # 查询最近订单
```

## 3. 推荐算法执行流程

### 3.1 个性化推荐流程
```
1. 请求接收与参数验证
   ├── 验证用户ID有效性
   ├── 验证推荐场景参数
   ├── 验证分页参数
   └── 检查请求频率限制

2. 用户画像构建
   ├── 检查用户画像缓存 (Redis)
   ├── 如果缓存未命中，从数据库构建
   │   ├── 查询用户基础信息
   │   ├── 查询用户行为历史
   │   ├── 查询用户标签偏好
   │   ├── 计算用户活跃度
   │   └── 缓存用户画像 (TTL: 1小时)
   └── 返回用户画像对象

3. 候选集召回 (多路召回策略)
   ├── 热门召回 (20%)
   │   └── 从Redis获取全局热门陪玩师
   ├── 标签召回 (30%)
   │   └── 基于用户标签偏好从ES召回
   ├── 协同过滤召回 (25%)
   │   ├── 查找相似用户
   │   └── 召回相似用户喜欢的陪玩师
   ├── 内容召回 (20%)
   │   └── 基于陪玩师特征相似度召回
   └── 新颖性召回 (5%)
       └── 推荐用户未接触过的新陪玩师

4. 特征计算与评分
   ├── 相关性评分 (权重: 0.3)
   │   ├── 标签匹配度
   │   ├── 技能匹配度
   │   └── 游戏偏好匹配度
   ├── 质量评分 (权重: 0.25)
   │   ├── 陪玩师评分
   │   ├── 服务质量
   │   └── 用户满意度
   ├── 流行度评分 (权重: 0.2)
   │   ├── 近期订单量
   │   ├── 用户关注度
   │   └── 搜索热度
   ├── 价格评分 (权重: 0.15)
   │   ├── 价格合理性
   │   ├── 性价比
   │   └── 用户价格敏感度
   └── 时间评分 (权重: 0.1)
       ├── 在线时间匹配
       ├── 响应速度
       └── 服务时长偏好

5. 混合算法排序
   ├── 加权线性组合
   │   └── Score = Σ(算法i权重 × 算法i得分)
   ├── 多样性优化
   │   ├── 类别多样性 (游戏类型)
   │   ├── 价格多样性 (不同价位)
   │   └── 技能多样性 (不同技能等级)
   └── 去重处理
       ├── 移除重复陪玩师
       └── 移除用户已下单的陪玩师

6. 业务规则过滤
   ├── 在线状态过滤 (只推荐在线的)
   ├── 黑名单过滤 (移除拉黑的)
   ├── 地域过滤 (基于用户地区偏好)
   ├── 价格范围过滤
   └── 服务时间过滤

7. 结果缓存与返回
   ├── 缓存推荐结果 (TTL: 30分钟)
   ├── 记录推荐日志
   ├── 更新推荐指标
   └── 返回最终推荐列表
```

### 3.2 搜索推荐流程
```
1. 搜索请求处理
   ├── 解析搜索关键词
   ├── 提取搜索意图
   ├── 构建搜索查询
   └── 设置搜索过滤条件

2. Elasticsearch检索
   ├── 全文检索 (陪玩师昵称、简介)
   ├── 标签匹配检索
   ├── 技能匹配检索
   ├── 地理位置检索
   └── 聚合统计检索

3. 搜索结果排序
   ├── 相关性得分 (ES原生得分)
   ├── 质量得分 (评分、订单量)
   ├── 时间得分 (最近活跃时间)
   └── 个性化得分 (基于用户偏好)

4. 搜索结果优化
   ├── 同义词扩展
   ├── 拼写纠错
   ├── 搜索建议
   └── 相关推荐
```

## 4. 缓存架构设计

### 4.1 多级缓存架构
```
Level 1: JVM本地缓存 (Caffeine)
├── 配置缓存 (算法参数、业务配置)
├── 热点数据缓存 (热门标签、热门游戏)
├── 计算结果缓存 (相似度矩阵、特征向量)
└── 查询结果缓存 (频繁查询的数据)

Level 2: 分布式缓存 (Redis)
├── 用户画像缓存 (用户偏好、行为特征)
├── 推荐结果缓存 (个性化推荐列表)
├── 会话缓存 (用户会话状态)
├── 热门数据缓存 (全局热门陪玩师)
└── 计数器缓存 (访问次数、点击次数)

Level 3: 数据库缓存 (MySQL Query Cache)
├── 查询结果缓存
├── 表数据缓存
└── 索引缓存
```

### 4.2 缓存策略
```
写策略:
├── Cache-Aside Pattern (旁路缓存)
│   ├── 适用: 推荐结果、用户画像
│   └── 逻辑: 先更新数据库，再删除缓存
├── Write-Through Pattern (写穿透)
│   ├── 适用: 用户会话、实时计数
│   └── 逻辑: 同时更新缓存和数据库
└── Write-Behind Pattern (写回)
    ├── 适用: 用户行为日志、点击统计
    └── 逻辑: 先更新缓存，异步更新数据库

读策略:
├── Cache-First (缓存优先)
│   └── 优先从缓存读取，缓存未命中才查数据库
├── Cache-Last (数据库优先)
│   └── 优先从数据库读取，用于实时性要求高的数据
└── Cache-Only (仅缓存)
    └── 只从缓存读取，用于临时性数据

失效策略:
├── TTL失效 (时间过期)
│   ├── 用户画像: 1小时
│   ├── 推荐结果: 30分钟
│   ├── 热门数据: 15分钟
│   └── 会话数据: 2小时
├── 手动失效 (业务触发)
│   ├── 用户信息更新触发画像失效
│   ├── 陪玩师状态变更触发相关缓存失效
│   └── 系统配置更新触发配置缓存失效
└── 事件驱动失效
    ├── 监听数据库变更事件
    ├── 监听用户行为事件
    └── 监听系统状态事件
```

## 5. 监控与告警

### 5.1 监控指标体系
```
系统性能指标:
├── QPS (每秒查询数)
├── RT (响应时间)
├── CPU使用率
├── 内存使用率
├── 磁盘IO
├── 网络IO
└── JVM性能指标

推荐质量指标:
├── 召回率 (Recall)
├── 精确率 (Precision)
├── 覆盖率 (Coverage)
├── 多样性 (Diversity)
├── 新颖性 (Novelty)
└── 满意度 (Satisfaction)

业务指标:
├── 点击率 (CTR)
├── 转化率 (CVR)
├── 订单完成率
├── 用户留存率
├── 收入指标 (GMV)
└── 用户满意度评分

技术指标:
├── 缓存命中率
├── 数据库连接池状态
├── 异常错误率
├── 接口成功率
├── 依赖服务可用性
└── 消息队列积压
```

### 5.2 告警策略
```
P0级告警 (立即处理):
├── 服务完全不可用
├── 数据库连接失败
├── 缓存集群故障
├── 推荐成功率 < 90%
└── 响应时间 > 5秒

P1级告警 (1小时内处理):
├── 推荐质量明显下降
├── 缓存命中率 < 80%
├── 错误率 > 5%
├── CPU使用率 > 80%
└── 内存使用率 > 85%

P2级告警 (当天处理):
├── 推荐多样性下降
├── 新用户推荐效果差
├── 某个算法效果异常
└── 依赖服务偶发异常

告警通道:
├── Feishu机器人 (即时通知)
├── 邮件通知 (详细报告)
├── 短信通知 (紧急情况)
└── 监控大屏 (实时展示)
```

## 6. 部署架构

### 6.1 环境规划
```
开发环境 (DEV):
├── 单机部署
├── 内存数据库 (H2)
├── 本地缓存
└── 日志级别: DEBUG

测试环境 (TEST):
├── 集群部署 (2个节点)
├── MySQL主从
├── Redis单机
└── 日志级别: INFO

预生产环境 (PRE):
├── 与生产环境一致的架构
├── 压力测试
├── 性能调优
└── 监控验证

生产环境 (PROD):
├── 集群部署 (3+个节点)
├── MySQL主从 + 读写分离
├── Redis集群
├── Elasticsearch集群
└── 日志级别: WARN
```

### 6.2 容器化部署
```
Docker镜像构建:
├── 基础镜像: openjdk:17-jre-slim
├── 应用JAR包
├── 配置文件
├── 启动脚本
└── 健康检查脚本

Kubernetes部署:
├── Deployment (应用部署)
├── Service (服务发现)
├── ConfigMap (配置管理)
├── Secret (敏感信息)
├── HPA (水平扩缩容)
├── Ingress (流量入口)
└── PVC (持久化存储)

服务网格 (Istio):
├── 流量管理
├── 安全策略
├── 可观测性
└── 灰度发布
```

## 7. 性能优化策略

### 7.1 算法优化
```
召回优化:
├── 预计算用户相似度矩阵
├── 构建倒排索引
├── 使用近似算法 (LSH)
└── 分层召回策略

排序优化:
├── 特征预计算
├── 模型在线推理优化
├── 批量评分
└── 并行计算

缓存优化:
├── 热点数据预热
├── 缓存预加载
├── 布隆过滤器防穿透
└── 分布式锁防击穿
```

### 7.2 系统优化
```
数据库优化:
├── 索引优化
├── 查询优化
├── 分库分表
├── 读写分离
└── 连接池调优

JVM优化:
├── 堆内存调优
├── GC算法选择
├── JIT编译优化
└── 内存泄漏监控

网络优化:
├── 连接复用
├── 数据压缩
├── 批量操作
└── 异步处理
```

## 8. 安全设计

### 8.1 数据安全
```
数据加密:
├── 传输加密 (HTTPS/TLS)
├── 存储加密 (数据库字段加密)
├── 缓存加密 (Redis数据加密)
└── 备份加密

隐私保护:
├── 数据脱敏
├── 匿名化处理
├── 访问控制
└── 审计日志
```

### 8.2 接口安全
```
认证授权:
├── JWT Token认证
├── OAuth2.0授权
├── API密钥管理
└── 权限控制

防护措施:
├── 请求频率限制
├── 参数校验
├── SQL注入防护
├── XSS攻击防护
└── CSRF攻击防护
```

## 9. 扩展性设计

### 9.1 算法扩展
```
插件化架构:
├── 算法接口标准化
├── 算法热插拔
├── A/B测试框架
└── 算法效果评估

新算法集成:
├── 深度学习模型 (TensorFlow)
├── 图神经网络 (DGL)
├── 强化学习算法
└── 联邦学习框架
```

### 9.2 业务扩展
```
多场景支持:
├── 游戏推荐
├── 直播推荐
├── 内容推荐
└── 商品推荐

国际化支持:
├── 多语言支持
├── 多地域部署
├── 本地化算法
└── 文化适配
```

这个架构设计文档详细描述了主播推荐系统的各个层面，包括技术架构、执行流程、缓存设计、监控告警、部署方案等，为系统的开发、部署和运维提供了全面的指导。

## 📋 系统转换总结

本系统已成功从陪玩师推荐平台转换为主播推荐平台，主要变更包括：

### 🔄 核心概念转换
- **陪玩师(GameMaster)** → **主播(Streamer)**
- **游戏(Game)** → **直播分类(Category)**  
- **陪玩技能** → **直播才艺**
- **陪玩订单** → **直播场次**
- **游戏匹配** → **分类匹配**

### 🗄️ 数据库结构调整
- `game_master` → `streamer` (主播基础信息)
- `game_master_interaction` → `streamer_interaction` (用户主播交互)
- `game_master_tag` → `streamer_tag` (主播标签关联)
- `game_master_game` → `streamer_category` (主播分类关联)
- `game` → `category` (直播分类)

### 🔧 服务层重构
- `GameMasterService` → `StreamerService`
- `PlayerSearchService` → `StreamerSearchService`
- `GameMasterController` → `StreamerController`
- `PlayerSearchController` → `StreamerSearchController`

### 📊 业务逻辑适配
- **价格模式**: 小时费用 → 礼物单价
- **评价体系**: 陪玩评分 → 主播评分
- **匹配算法**: 游戏技能匹配 → 直播风格匹配
- **推荐场景**: 游戏陪玩 → 社交直播

### 🎯 个性化推荐执行流程：
1. **请求处理** → 参数验证 → 频率限制
2. **用户画像构建** → 缓存检查 → 数据查询 → 画像计算
3. **多路召回** → 热门召回(20%) + 标签召回(30%) + 协同过滤(25%) + 内容召回(20%) + 新颖性召回(5%)
4. **特征计算** → 相关性(30%) + 质量(25%) + 流行度(20%) + 价格(15%) + 时间(10%)
5. **混合排序** → 加权组合 → 多样性优化 → 去重处理
6. **业务过滤** → 在线状态 → 黑名单 → 地域 → 分类过滤
7. **结果返回** → 缓存结果 → 记录指标 → 返回主播列表

### 🚀 系统特性：
- **高性能**: 多级缓存 + 异步处理 + 连接池优化
- **高可用**: 服务集群 + 熔断降级 + 优雅降级
- **可扩展**: 微服务架构 + 水平扩展 + 插件化算法
- **国际化**: 多语言支持 + 地域化推荐
- **监控**: 全链路监控 + 实时告警 + 性能分析

### 🎯 关键技术点
- **微服务架构** - Spring Cloud + Nacos服务治理
- **多级缓存** - JVM本地缓存 + Redis分布式缓存 + 数据库缓存
- **多路召回策略** - 热门/标签/协同过滤/内容/新颖性多渠道召回
- **混合推荐算法** - 协同过滤 + 基于内容 + 混合算法
- **实时监控** - Prometheus + Grafana + 业务指标监控
- **容器化部署** - Docker + Kubernetes + Istio服务网格

系统保持了原有的推荐算法框架和业务规则，仅调整了业务领域概念，确保推荐引擎的核心能力完整保留。